# @file test_check_config.py
#
# Copyright (C) Metaswitch Networks 2018
# If license terms are provided to you in a COPYING file in the root directory
# of the source code repository by which you are accessing this code, then
# the license outlined in that COPYING file applies to your use.
# Otherwise no rights are granted except for those provided to you by
# Metaswitch Networks in a separate written agreement.

import unittest
import mock
import hypothesis
import hypothesis.strategies as st

from cw_infrastructure import check_config_utilities as utils
from cw_infrastructure import check_config


class TestCheckConfig(unittest.TestCase):

    """
    Helper classes and methods
    """

    class TestOptionSchema():
        def __init__(self):
            self.options = []
            self.advanced_checks = []

        def get_options(self):
            return self.options

        def get_advanced_checks(self):
            return self.advanced_checks

    class TestValues():
        def __init__(self):
            self.values = {}

        def get_value(self, key):
            if key in self.values:
                return self.values[key]
            else:
                return None

    def setUp(self):
        self.option_schema = TestCheckConfig.TestOptionSchema()
        self.values = TestCheckConfig.TestValues()

    def add_option(self, option):
        self.option_schema.options.append(option)

    def set_advanced_check(self, check):
        self.option_schema.advanced_checks = [check]

    def add_value(self, option_name, value):
        self.values.values[option_name] = value

    def run_check_config(self,
                         expected_result,
                         error_options=[],
                         warning_options=[]):
        self._run_check_config(expected_result, error_options, warning_options)

    @mock.patch('cw_infrastructure.check_config_utilities.error',
                autospec=True)
    @mock.patch('cw_infrastructure.check_config_utilities.warning',
                autospec=True)
    def _run_check_config(self,
                          expected_result,
                          error_options,
                          warning_options,
                          mock_warning,
                          mock_error):
        status = check_config.check_config(self.option_schema,
                                           self.values.get_value)
        self.assertEqual(expected_result, status)
        mock_error.assert_has_calls([mock.call(x, mock.ANY)
                                     for x in error_options])
        mock_warning.assert_has_calls([mock.call(x, mock.ANY)
                                       for x in warning_options])

    """
    Tests
    """

    # Test that the user is warned if a deprecated option is set
    def test_warn_deprecated(self):
        option_name = 'deprecated_option'
        option = utils.Option(option_name, utils.Option.DEPRECATED)
        self.add_option(option)
        self.add_value(option_name, 'value is set')
        self.run_check_config(utils.WARNING,
                              warning_options=[option_name])

    # Test that a deprecated option is still validated, and returns an error if
    # validation returns one
    def test_error_deprecated(self):
        mock_validator = mock.Mock()
        mock_validator.return_value = utils.ERROR

        option_name = 'deprecated_option'
        option = utils.Option(option_name,
                              utils.Option.DEPRECATED,
                              mock_validator)
        self.add_option(option)
        self.add_value(option_name, 'value is set')

        self.run_check_config(utils.ERROR,
                              warning_options=[option_name])

    # Test that the user is warned is a suggested option is not set
    def test_warn_suggested(self):
        option_name = 'suggested_option'
        option = utils.Option(option_name, utils.Option.SUGGESTED)
        self.add_option(option)
        self.run_check_config(utils.WARNING,
                              warning_options=[option_name])

    # Test that an error is returned if a mandatory option is not set
    def test_error_mandatory(self):
        option_name = 'mandatory_option'
        option = utils.Option(option_name, utils.Option.MANDATORY)
        self.add_option(option)
        self.run_check_config(utils.ERROR,
                              error_options=[option_name])

    # Test that checking a config option returns the return code of its
    # validator, for all possible validator return codes.
    @hypothesis.given(st.sampled_from([utils.OK, utils.WARNING, utils.ERROR]))
    def test_run_validator(self, return_value):

        # Due to a known bug in hypothesis, setUp isn't automatically called
        # before running each autogenerated case, so we must call it manually.
        self.setUp()
        mock_validator = mock.Mock()

        # Return value is sampled from [ok, warning, error] by hypothesis
        mock_validator.return_value = return_value

        option_name = 'validated_option'
        option = utils.Option(option_name,
                              utils.Option.MANDATORY,
                              mock_validator)

        self.add_option(option)
        self.add_value(option_name, 'value')

        self.run_check_config(return_value)


if __name__ == '__main__':
    unittest.main()
